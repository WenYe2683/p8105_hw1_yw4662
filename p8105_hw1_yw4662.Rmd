---
title: "p8105_hw1_yw4662"
output: github_document
---
## Problem 1
### Setup
```{r}
library(moderndive) # load the moderndive dataset
library(ggplot2) # load plotting
data("early_january_weather") #load the early_january_weather dataset from moderndive data
```

### Short description of the dataset
This dataset contains hourly weather observations for NYC airports over early January.

* **Time span**: from `r format(min(early_january_weather$time_hour),"%Y-%m-%d %H:%M")` to `r format(max(early_january_weather$time_hour),"%Y-%m-%d %H:%M")`.

* **Size**: `r nrow(early_january_weather)` rows $\times$ `r ncol(early_january_weather)` columns.

* **Variables**: `r paste(names(early_january_weather), collapse = ", ")`.

* **Mean air temperature**: `r round(mean(early_january_weather$temp, na.rm=TRUE),1)`°F

### Scatterplot: `temp` vs `time_hour`, colored by `humid`
```{r}
ggplot(early_january_weather,
            aes(x = time_hour, y = temp, color = humid)) +
  geom_point(alpha = 0.7, size = 1.3) +
  labs(
    title = "Temperature over time, colored by relative humidity",
    x = "Time (hourly)",
    y = "Temperature (°F)",
    color = "Humidity"
  )
```

### Brief description of patterns
Temperatures fluctuate in daily cycles, generally cooler overnight and warmer during daytime. Points with lower humidity (darker colors) tend to appear during cooler periods, suggesting a direct relationship between temperature and relative humidity.

```{r}
ggsave(
  filename = "temp_vs_time_hour_by_humid.png"
)
```

## Problem 2

### Setup
```{r}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
```


### Creating the data frame

```{r}
# random sample of size 10 from a standard Normal distribution
num <- rnorm(10)

# logical vector indicating whether elements of the sample are greater than 0
logic_0 <- num > 0

# character vector of length 10: a,...,j
char_10 <- letters[1:10]

# factor vector of length 10 with 3 different factor levels
factor_3levels <- factor(sample(c("low", "medium", "high"),
                       size = 10, replace = TRUE),
                levels = c("low", "medium", "high"),
                ordered = TRUE)       

df <- tibble(num, logic_0, char_10, factor_3levels)
df
```

### Taking the mean of each variable 

```{r}
# For the numeric variable

mean(pull(df,num))

# For the logical variable

mean(pull(df, logic_0))

# For the character variable

mean(pull(df, char_10))

# For the factor variable

mean(pull(df,factor_3levels))
```

**What works/doesn't work and why:**

- `num`: because it is numeric, its mean is defined
- `logic_0`: because logical values are internally `TRUE=1`, `FALSE=0`, its mean is essentially the proportion of `TRUE` and hence defined
- `char_10`: because characters are not numeric, it returns with an error (NA)
- `factor_3levels`: factors are stored as integers with labels, but `mean()` refuses because the class is `factor` not `numeric`, and hence it returns with an error (NA)

### Coercion with `as.numeric()`

```{r}

num_logical <- as.numeric(df$logic_0)
num_character <- as.numeric(df$char_10)
num_factor <- as.numeric(df$factor_3levels)

```

**Explanations for what happens:**

- `as.numeric(logic_0)` returns `0/1`, which explains why `mean(logic_0)` works (the share of `TRUE`)
- `as.numeric(char_10)` returns `NA` with a warning, this is because characters don't map to numbers
- `as.numeric(factor_3levels)` returns the codes of the factor levles (`low=1`, `medium=2`, `high=3`)
